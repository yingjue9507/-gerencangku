# 多AI集成浏览器 - 技术实现方案

## 重要技术决策说明

基于对各大AI公司反集成机制的深入分析，我们决定采用**自建浏览器**方案，而非传统的浏览器插件。这一决策能够完美解决跨域限制、反自动化检测等技术挑战。

## 1. 总体架构设计

### 1.1 自建浏览器系统架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        多AI集成浏览器                                  │
│                      (基于 Electron + Chromium)                      │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐   │
│  │   主控制面板     │  │   AI标签页管理   │  │     统一对话界面     │   │
│  │   (React UI)    │  │   (Multi-Tab)   │  │    (Chat Aggregator) │   │
│  └─────────────────┘  └─────────────────┘  └─────────────────────┘   │
│           │                      │                      │            │
│           └──────────────────────┼──────────────────────┘            │
│                                  │                                   │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                    核心引擎层 (Node.js Backend)                   │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │
│  │  │ 脚本注入器   │ │ 消息总线     │ │ 数据提取器   │ │ 状态管理器   │ │ │
│  │  │ (Injector)  │ │ (Message Bus)│ │ (Extractor) │ │ (State Mgr) │ │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        AI服务集成层                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐ │
│  │   ChatGPT   │ │   Claude    │ │   Gemini    │ │   其他AI服务     │ │
│  │  (网页嵌入)  │ │  (网页嵌入)  │ │  (网页嵌入)  │ │  (网页/API)     │ │
│  │  + 脚本注入  │ │  + 脚本注入  │ │  + 脚本注入  │ │  + 自定义适配   │ │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 核心组件说明

#### 1.2.1 主控制面板 (React UI)
- **职责**: 用户交互的主界面
- **功能**:
  - 统一的多AI对话界面
  - AI服务管理和配置
  - 对话历史和导出功能
  - 个性化设置和主题

#### 1.2.2 AI标签页管理器 (Multi-Tab Manager)
- **职责**: 管理多个AI服务的网页实例
- **功能**:
  - 动态创建和销毁AI服务标签页
  - 维护各AI服务的登录状态
  - 标签页间的资源隔离
  - 自动重连和错误恢复

#### 1.2.3 脚本注入器 (Script Injector)
- **职责**: 向AI网站注入自定义脚本
- **功能**:
  - 自动检测页面加载状态
  - 注入数据提取和交互脚本
  - 绕过网站的反自动化检测
  - 适配不同AI网站的页面结构

#### 1.2.4 消息总线 (Message Bus)
- **职责**: 统一的消息通信中心
- **功能**:
  - 跨标签页消息传递
  - 实时数据同步
  - 事件分发和处理
  - 错误传播和处理

#### 1.2.5 数据提取器 (Data Extractor)
- **职责**: 从AI网站提取对话数据
- **功能**:
  - 实时监听对话内容变化
  - 解析和格式化AI回复
  - 提取元数据（时间戳、模型信息等）
  - 处理流式响应数据

#### 1.2.6 状态管理器 (State Manager)
- **职责**: 管理应用全局状态
- **功能**:
  - 维护各AI服务连接状态
  - 管理用户配置和偏好
  - 缓存对话历史
  - 数据持久化存储

## 1.3 自建浏览器的技术优势

### 1.3.1 完全绕过跨域限制
- **无CORS限制**: 作为独立应用，不受浏览器同源策略限制
- **无CSP限制**: 可以注入任意JavaScript代码
- **无iframe限制**: 可以完整加载任何网站

### 1.3.2 反检测能力
- **真实浏览器环境**: 基于Chromium，与真实用户行为无异
- **完全控制请求**: 可以模拟真实的用户操作模式
- **动态指纹**: 可以动态调整浏览器指纹特征

### 1.3.3 用户体验优势
- **原生性能**: 不依赖浏览器插件，性能更优
- **完整功能**: 保留AI网站的所有原生功能
- **多窗口支持**: 真正的并行多AI对话

## 2. 关键技术实现

### 2.1 基于Electron的AI服务集成架构

#### 2.1.1 Electron主进程架构

```typescript
// 主进程 - 管理所有AI服务窗口
class AIBrowserManager {
  private aiWindows: Map<string, BrowserWindow> = new Map();
  private messageHandlers: Map<string, Function> = new Map();
  
  // 创建AI服务窗口
  async createAIWindow(serviceId: string, config: AIServiceConfig): Promise<BrowserWindow> {
    const window = new BrowserWindow({
      width: 1200,
      height: 800,
      show: false, // 隐藏窗口，通过主界面控制
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'ai-service-preload.js'),
        webSecurity: false // 关键：允许跨域访问
      }
    });
    
    // 注入自定义脚本
    await this.injectCustomScripts(window, serviceId);
    
    // 加载AI服务网站
    await window.loadURL(config.url);
    
    this.aiWindows.set(serviceId, window);
    return window;
  }
  
  // 脚本注入系统
  private async injectCustomScripts(window: BrowserWindow, serviceId: string) {
    const scriptPath = path.join(__dirname, 'adapters', `${serviceId}.js`);
    const script = await fs.readFile(scriptPath, 'utf8');
    
    window.webContents.on('dom-ready', () => {
      window.webContents.executeJavaScript(script);
    });
  }
}
```

#### 2.1.2 AI服务适配器接口

```typescript
interface AIServiceAdapter {
  // 基础信息
  serviceId: string;
  name: string;
  url: string;
  icon: string;
  
  // 窗口管理
  window?: BrowserWindow;
  isReady: boolean;
  
  // 消息处理
  sendMessage(message: string, options?: MessageOptions): Promise<AIResponse>;
  sendStreamMessage(message: string, callback: (chunk: string) => void): Promise<void>;
  
  // 页面交互
  extractResponse(): Promise<string>;
  inputMessage(message: string): Promise<void>;
  clickSendButton(): Promise<void>;
  
  // 状态管理
  checkLoginStatus(): Promise<boolean>;
  waitForResponse(): Promise<string>;
  clearConversation(): Promise<void>;
}
```

#### 2.1.3 具体AI服务适配器实现

```typescript
// ChatGPT适配器示例
class ChatGPTAdapter implements AIServiceAdapter {
  serviceId = 'chatgpt';
  name = 'ChatGPT';
  url = 'https://chat.openai.com';
  icon = 'chatgpt-icon.svg';
  window?: BrowserWindow;
  isReady = false;
  
  async sendMessage(message: string): Promise<AIResponse> {
    if (!this.window) throw new Error('Window not initialized');
    
    // 注入消息到输入框
    await this.inputMessage(message);
    
    // 点击发送按钮
    await this.clickSendButton();
    
    // 等待响应
    const response = await this.waitForResponse();
    
    return {
      content: response,
      timestamp: Date.now(),
      service: this.serviceId
    };
  }
  
  async inputMessage(message: string): Promise<void> {
    const script = `
      const textarea = document.querySelector('textarea[data-id="root"]') || 
                      document.querySelector('#prompt-textarea') ||
                      document.querySelector('textarea');
      if (textarea) {
        textarea.value = ${JSON.stringify(message)};
        textarea.dispatchEvent(new Event('input', { bubbles: true }));
      }
    `;
    
    await this.window!.webContents.executeJavaScript(script);
  }
  
  async clickSendButton(): Promise<void> {
    const script = `
      const sendButton = document.querySelector('button[data-testid="send-button"]') ||
                        document.querySelector('button[aria-label="Send prompt"]') ||
                        document.querySelector('button:has(svg)');
      if (sendButton && !sendButton.disabled) {
        sendButton.click();
      }
    `;
    
    await this.window!.webContents.executeJavaScript(script);
  }
  
  async waitForResponse(): Promise<string> {
    return new Promise((resolve) => {
      const checkResponse = async () => {
        const script = `
          const messages = document.querySelectorAll('[data-message-author-role="assistant"]');
          const lastMessage = messages[messages.length - 1];
          if (lastMessage) {
            return lastMessage.textContent || lastMessage.innerText;
          }
          return null;
        `;
        
        const response = await this.window!.webContents.executeJavaScript(script);
        if (response) {
          resolve(response);
        } else {
          setTimeout(checkResponse, 1000);
        }
      };
      
      checkResponse();
    });
  }
}
    // 创建iframe并加载AI网站
    this.iframe = document.createElement('iframe');
    this.iframe.src = this.config.url;
    this.iframe.style.display = 'none';
    document.body.appendChild(this.iframe);
    
    // 等待页面加载完成
    return new Promise((resolve) => {
      this.iframe.onload = () => {
        this.injectContentScript();
        resolve(true);
      };
    });
  }
  
  private injectContentScript(): void {
    // 注入内容脚本到iframe中
    const script = `
      // 监听来自插件的消息
      window.addEventListener('message', (event) => {
        if (event.data.type === 'SEND_MESSAGE') {
          this.simulateUserInput(event.data.message);
        }
      });
      
      // 模拟用户输入
      function simulateUserInput(message) {
        const inputElement = document.querySelector('${this.config.inputSelector}');
        if (inputElement) {
          inputElement.value = message;
          inputElement.dispatchEvent(new Event('input', { bubbles: true }));
          
          const submitButton = document.querySelector('${this.config.submitSelector}');
          if (submitButton) {
            submitButton.click();
          }
        }
      }
      
      // 监听AI回复
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList') {
            const newMessages = document.querySelectorAll('${this.config.responseSelector}');
            // 发送新消息到插件
            window.parent.postMessage({
              type: 'AI_RESPONSE',
              message: newMessages[newMessages.length - 1]?.textContent
            }, '*');
          }
        });
      });
      
      observer.observe(document.body, { childList: true, subtree: true });
    `;
    
    this.iframe.contentWindow?.eval(script);
  }
  
  async sendMessage(message: string): Promise<string> {
    return new Promise((resolve) => {
      // 发送消息到iframe
      this.iframe.contentWindow?.postMessage({
        type: 'SEND_MESSAGE',
        message: message
      }, '*');
      
      // 监听回复
      const messageHandler = (event: MessageEvent) => {
        if (event.data.type === 'AI_RESPONSE') {
          window.removeEventListener('message', messageHandler);
          resolve(event.data.message);
        }
      };
      
      window.addEventListener('message', messageHandler);
    });
  }
}
```

#### 2.1.3 API类型适配器实现

```typescript
class APIAIAdapter implements AIServiceAdapter {
  private apiKey: string;
  private baseUrl: string;
  private currentSessionId?: string;
  
  async sendMessage(message: string, options?: MessageOptions): Promise<string> {
    const requestBody = this.formatRequest(message, options);
    
    try {
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
          ...this.config.headers
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        throw new Error(`API请求失败: ${response.status}`);
      }
      
      const data = await response.json();
      return this.parseResponse(data);
    } catch (error) {
      console.error('API调用错误:', error);
      throw error;
    }
  }
  
  async sendStreamMessage(message: string, callback: (chunk: string) => void): Promise<void> {
    const requestBody = this.formatRequest(message, { stream: true });
    
    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
        ...this.config.headers
      },
      body: JSON.stringify(requestBody)
    });
    
    const reader = response.body?.getReader();
    if (!reader) return;
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = new TextDecoder().decode(value);
      const lines = chunk.split('\n').filter(line => line.trim());
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') return;
          
          try {
            const parsed = JSON.parse(data);
            const content = parsed.choices[0]?.delta?.content;
            if (content) {
              callback(content);
            }
          } catch (e) {
            console.error('解析流数据错误:', e);
          }
        }
      }
    }
  }
  
  private formatRequest(message: string, options?: MessageOptions): any {
    // 根据不同AI服务的API格式进行转换
    switch (this.config.apiFormat) {
      case 'openai':
        return {
          model: this.config.model || 'gpt-3.5-turbo',
          messages: [{ role: 'user', content: message }],
          stream: options?.stream || false,
          ...options
        };
      
      case 'claude':
        return {
          model: this.config.model || 'claude-3-sonnet-20240229',
          max_tokens: options?.max_tokens || 1000,
          messages: [{ role: 'user', content: message }],
          stream: options?.stream || false
        };
      
      default:
        return { message, ...options };
    }
  }
  
  private parseResponse(data: any): string {
    // 根据不同AI服务的响应格式进行解析
    switch (this.config.apiFormat) {
      case 'openai':
        return data.choices[0]?.message?.content || '';
      
      case 'claude':
        return data.content[0]?.text || '';
      
      default:
        return data.response || data.message || '';
    }
  }
}
```

### 2.2 统一消息管理系统

#### 2.2.1 消息管理器

```typescript
class MessageManager {
  private adapters: Map<string, AIServiceAdapter> = new Map();
  private conversations: Map<string, Conversation> = new Map();
  
  // 注册AI服务适配器
  registerAdapter(id: string, adapter: AIServiceAdapter): void {
    this.adapters.set(id, adapter);
  }
  
  // 向单个AI发送消息
  async sendToAI(aiId: string, message: string, conversationId?: string): Promise<AIResponse> {
    const adapter = this.adapters.get(aiId);
    if (!adapter) {
      throw new Error(`AI服务 ${aiId} 未找到`);
    }
    
    const startTime = Date.now();
    
    try {
      const response = await adapter.sendMessage(message);
      const endTime = Date.now();
      
      const aiResponse: AIResponse = {
        id: generateId(),
        aiId,
        message,
        response,
        timestamp: new Date(),
        responseTime: endTime - startTime,
        conversationId
      };
      
      // 保存到对话历史
      if (conversationId) {
        this.addToConversation(conversationId, aiResponse);
      }
      
      return aiResponse;
    } catch (error) {
      throw new Error(`AI ${aiId} 响应错误: ${error.message}`);
    }
  }
  
  // 向多个AI同时发送消息
  async sendToMultipleAIs(aiIds: string[], message: string, conversationId?: string): Promise<AIResponse[]> {
    const promises = aiIds.map(aiId => 
      this.sendToAI(aiId, message, conversationId).catch(error => ({
        id: generateId(),
        aiId,
        message,
        response: '',
        error: error.message,
        timestamp: new Date(),
        responseTime: 0,
        conversationId
      }))
    );
    
    return Promise.all(promises);
  }
  
  // 流式发送消息
  async sendStreamToAI(aiId: string, message: string, callback: (chunk: StreamChunk) => void): Promise<void> {
    const adapter = this.adapters.get(aiId);
    if (!adapter) {
      throw new Error(`AI服务 ${aiId} 未找到`);
    }
    
    await adapter.sendStreamMessage(message, (content: string) => {
      callback({
        aiId,
        content,
        timestamp: new Date()
      });
    });
  }
}
```

#### 2.2.2 对话管理

```typescript
interface Conversation {
  id: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
  messages: ConversationMessage[];
  tags: string[];
  aiServices: string[];
}

interface ConversationMessage {
  id: string;
  type: 'user' | 'ai';
  content: string;
  aiId?: string;
  timestamp: Date;
  metadata?: {
    responseTime?: number;
    error?: string;
    tokens?: number;
  };
}

class ConversationManager {
  private storage: StorageManager;
  
  constructor(storage: StorageManager) {
    this.storage = storage;
  }
  
  // 创建新对话
  async createConversation(title?: string): Promise<Conversation> {
    const conversation: Conversation = {
      id: generateId(),
      title: title || `对话 ${new Date().toLocaleString()}`,
      createdAt: new Date(),
      updatedAt: new Date(),
      messages: [],
      tags: [],
      aiServices: []
    };
    
    await this.storage.saveConversation(conversation);
    return conversation;
  }
  
  // 添加消息到对话
  async addMessage(conversationId: string, message: ConversationMessage): Promise<void> {
    const conversation = await this.storage.getConversation(conversationId);
    if (!conversation) {
      throw new Error('对话不存在');
    }
    
    conversation.messages.push(message);
    conversation.updatedAt = new Date();
    
    // 更新AI服务列表
    if (message.aiId && !conversation.aiServices.includes(message.aiId)) {
      conversation.aiServices.push(message.aiId);
    }
    
    await this.storage.saveConversation(conversation);
  }
  
  // 搜索对话
  async searchConversations(query: string, filters?: {
    tags?: string[];
    aiServices?: string[];
    dateRange?: { start: Date; end: Date };
  }): Promise<Conversation[]> {
    const conversations = await this.storage.getAllConversations();
    
    return conversations.filter(conv => {
      // 文本搜索
      const textMatch = conv.title.toLowerCase().includes(query.toLowerCase()) ||
        conv.messages.some(msg => msg.content.toLowerCase().includes(query.toLowerCase()));
      
      if (!textMatch) return false;
      
      // 标签过滤
      if (filters?.tags && filters.tags.length > 0) {
        const hasTag = filters.tags.some(tag => conv.tags.includes(tag));
        if (!hasTag) return false;
      }
      
      // AI服务过滤
      if (filters?.aiServices && filters.aiServices.length > 0) {
        const hasAI = filters.aiServices.some(ai => conv.aiServices.includes(ai));
        if (!hasAI) return false;
      }
      
      // 日期范围过滤
      if (filters?.dateRange) {
        const { start, end } = filters.dateRange;
        if (conv.createdAt < start || conv.createdAt > end) return false;
      }
      
      return true;
    });
  }
}
```

### 2.3 数据存储系统

#### 2.3.1 存储管理器

```typescript
class StorageManager {
  private readonly STORAGE_KEYS = {
    CONVERSATIONS: 'conversations',
    AI_CONFIGS: 'ai_configs',
    USER_SETTINGS: 'user_settings',
    API_KEYS: 'api_keys'
  };
  
  // 保存对话
  async saveConversation(conversation: Conversation): Promise<void> {
    const conversations = await this.getConversations();
    const index = conversations.findIndex(c => c.id === conversation.id);
    
    if (index >= 0) {
      conversations[index] = conversation;
    } else {
      conversations.push(conversation);
    }
    
    await chrome.storage.local.set({
      [this.STORAGE_KEYS.CONVERSATIONS]: conversations
    });
  }
  
  // 获取所有对话
  async getConversations(): Promise<Conversation[]> {
    const result = await chrome.storage.local.get(this.STORAGE_KEYS.CONVERSATIONS);
    return result[this.STORAGE_KEYS.CONVERSATIONS] || [];
  }
  
  // 保存AI配置
  async saveAIConfig(config: AIServiceConfig): Promise<void> {
    const configs = await this.getAIConfigs();
    const index = configs.findIndex(c => c.id === config.id);
    
    if (index >= 0) {
      configs[index] = config;
    } else {
      configs.push(config);
    }
    
    await chrome.storage.local.set({
      [this.STORAGE_KEYS.AI_CONFIGS]: configs
    });
  }
  
  // 安全存储API密钥
  async saveAPIKey(aiId: string, apiKey: string): Promise<void> {
    const encryptedKey = await this.encryptData(apiKey);
    const apiKeys = await this.getAPIKeys();
    apiKeys[aiId] = encryptedKey;
    
    await chrome.storage.local.set({
      [this.STORAGE_KEYS.API_KEYS]: apiKeys
    });
  }
  
  // 获取API密钥
  async getAPIKey(aiId: string): Promise<string | null> {
    const apiKeys = await this.getAPIKeys();
    const encryptedKey = apiKeys[aiId];
    
    if (!encryptedKey) return null;
    
    return await this.decryptData(encryptedKey);
  }
  
  // 数据加密
  private async encryptData(data: string): Promise<string> {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    
    // 生成随机密钥
    const key = await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
    
    // 生成随机IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    // 加密数据
    const encryptedBuffer = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      dataBuffer
    );
    
    // 导出密钥
    const exportedKey = await crypto.subtle.exportKey('raw', key);
    
    // 组合密钥、IV和加密数据
    const combined = new Uint8Array(exportedKey.byteLength + iv.length + encryptedBuffer.byteLength);
    combined.set(new Uint8Array(exportedKey), 0);
    combined.set(iv, exportedKey.byteLength);
    combined.set(new Uint8Array(encryptedBuffer), exportedKey.byteLength + iv.length);
    
    // 转换为Base64
    return btoa(String.fromCharCode(...combined));
  }
  
  // 数据解密
  private async decryptData(encryptedData: string): Promise<string> {
    try {
      // 从Base64解码
      const combined = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
      
      // 提取密钥、IV和加密数据
      const keyBuffer = combined.slice(0, 32);
      const iv = combined.slice(32, 44);
      const encryptedBuffer = combined.slice(44);
      
      // 导入密钥
      const key = await crypto.subtle.importKey(
        'raw',
        keyBuffer,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
      );
      
      // 解密数据
      const decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        encryptedBuffer
      );
      
      // 转换为字符串
      const decoder = new TextDecoder();
      return decoder.decode(decryptedBuffer);
    } catch (error) {
      console.error('解密失败:', error);
      throw new Error('数据解密失败');
    }
  }
}
```

### 2.4 用户界面实现

#### 2.4.1 主界面组件

```typescript
// React组件示例
import React, { useState, useEffect } from 'react';
import { Layout, Tabs, Button, Input, Card, Avatar, Spin } from 'antd';

const { Header, Content, Sider } = Layout;
const { TabPane } = Tabs;
const { TextArea } = Input;

interface MainInterfaceProps {
  messageManager: MessageManager;
  conversationManager: ConversationManager;
}

const MainInterface: React.FC<MainInterfaceProps> = ({ 
  messageManager, 
  conversationManager 
}) => {
  const [activeAIs, setActiveAIs] = useState<string[]>([]);
  const [currentMessage, setCurrentMessage] = useState('');
  const [responses, setResponses] = useState<Map<string, AIResponse>>(new Map());
  const [loading, setLoading] = useState<Set<string>>(new Set());
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);

  // 发送消息到所有激活的AI
  const handleSendMessage = async () => {
    if (!currentMessage.trim() || activeAIs.length === 0) return;

    setLoading(new Set(activeAIs));
    setResponses(new Map());

    try {
      // 创建新对话（如果需要）
      let conversation = currentConversation;
      if (!conversation) {
        conversation = await conversationManager.createConversation();
        setCurrentConversation(conversation);
      }

      // 添加用户消息
      await conversationManager.addMessage(conversation.id, {
        id: generateId(),
        type: 'user',
        content: currentMessage,
        timestamp: new Date()
      });

      // 发送到所有AI
      const aiResponses = await messageManager.sendToMultipleAIs(
        activeAIs, 
        currentMessage, 
        conversation.id
      );

      // 更新响应
      const newResponses = new Map();
      for (const response of aiResponses) {
        newResponses.set(response.aiId, response);
        
        // 添加AI响应到对话
        await conversationManager.addMessage(conversation.id, {
          id: generateId(),
          type: 'ai',
          content: response.response,
          aiId: response.aiId,
          timestamp: response.timestamp,
          metadata: {
            responseTime: response.responseTime,
            error: response.error
          }
        });
      }

      setResponses(newResponses);
      setCurrentMessage('');
    } catch (error) {
      console.error('发送消息失败:', error);
    } finally {
      setLoading(new Set());
    }
  };

  return (
    <Layout style={{ height: '100vh' }}>
      <Header style={{ background: '#fff', padding: '0 24px' }}>
        <h1>多AI对话助手</h1>
      </Header>
      
      <Layout>
        <Sider width={300} style={{ background: '#fff' }}>
          <AIServicePanel 
            onActiveAIsChange={setActiveAIs}
            activeAIs={activeAIs}
          />
        </Sider>
        
        <Content style={{ padding: '24px' }}>
          <div style={{ marginBottom: '16px' }}>
            <TextArea
              value={currentMessage}
              onChange={(e) => setCurrentMessage(e.target.value)}
              placeholder="输入您的问题..."
              rows={4}
              onPressEnter={(e) => {
                if (e.ctrlKey) {
                  handleSendMessage();
                }
              }}
            />
            <Button 
              type="primary" 
              onClick={handleSendMessage}
              loading={loading.size > 0}
              style={{ marginTop: '8px' }}
            >
              发送 (Ctrl+Enter)
            </Button>
          </div>
          
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(400px, 1fr))', gap: '16px' }}>
            {activeAIs.map(aiId => (
              <AIResponseCard
                key={aiId}
                aiId={aiId}
                response={responses.get(aiId)}
                loading={loading.has(aiId)}
              />
            ))}
          </div>
        </Content>
      </Layout>
    </Layout>
  );
};

// AI响应卡片组件
const AIResponseCard: React.FC<{
  aiId: string;
  response?: AIResponse;
  loading: boolean;
}> = ({ aiId, response, loading }) => {
  const aiConfig = useAIConfig(aiId);
  
  return (
    <Card
      title={
        <div style={{ display: 'flex', alignItems: 'center' }}>
          <Avatar src={aiConfig?.icon} size="small" style={{ marginRight: '8px' }} />
          {aiConfig?.name || aiId}
        </div>
      }
      style={{ height: '400px' }}
    >
      {loading ? (
        <div style={{ textAlign: 'center', padding: '50px' }}>
          <Spin size="large" />
          <p style={{ marginTop: '16px' }}>AI正在思考中...</p>
        </div>
      ) : response ? (
        <div>
          {response.error ? (
            <div style={{ color: 'red' }}>
              错误: {response.error}
            </div>
          ) : (
            <div style={{ whiteSpace: 'pre-wrap' }}>
              {response.response}
            </div>
          )}
          <div style={{ marginTop: '16px', fontSize: '12px', color: '#666' }}>
            响应时间: {response.responseTime}ms
          </div>
        </div>
      ) : (
        <div style={{ textAlign: 'center', color: '#999' }}>
          等待响应...
        </div>
      )}
    </Card>
  );
};
```

## 3. 部署和构建

### 3.1 项目结构

```
multi-ai-extension/
├── manifest.json                 # 插件清单文件
├── package.json                 # 依赖管理
├── webpack.config.js            # 构建配置
├── src/
│   ├── background/              # 后台脚本
│   │   ├── index.ts
│   │   ├── api-manager.ts
│   │   ├── storage-manager.ts
│   │   └── message-router.ts
│   ├── content/                 # 内容脚本
│   │   ├── index.ts
│   │   └── injector.ts
│   ├── popup/                   # 弹窗界面
│   │   ├── index.tsx
│   │   ├── popup.html
│   │   └── popup.css
│   ├── options/                 # 选项页面
│   │   ├── index.tsx
│   │   ├── options.html
│   │   └── components/
│   ├── adapters/                # AI适配器
│   │   ├── base-adapter.ts
│   │   ├── web-adapter.ts
│   │   ├── api-adapter.ts
│   │   └── specific/
│   │       ├── chatgpt-adapter.ts
│   │       ├── claude-adapter.ts
│   │       └── gemini-adapter.ts
│   ├── utils/                   # 工具函数
│   │   ├── crypto.ts
│   │   ├── storage.ts
│   │   └── message.ts
│   └── types/                   # 类型定义
│       ├── ai-service.ts
│       ├── conversation.ts
│       └── storage.ts
├── public/                      # 静态资源
│   ├── icons/
│   └── images/
└── dist/                        # 构建输出
```

### 3.2 构建配置

```javascript
// webpack.config.js
const path = require('path');
const CopyPlugin = require('copy-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: {
    background: './src/background/index.ts',
    content: './src/content/index.ts',
    popup: './src/popup/index.tsx',
    options: './src/options/index.tsx'
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    clean: true
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  },
  plugins: [
    new CopyPlugin({
      patterns: [
        { from: 'manifest.json', to: 'manifest.json' },
        { from: 'src/popup/popup.html', to: 'popup.html' },
        { from: 'src/options/options.html', to: 'options.html' },
        { from: 'public', to: 'public' }
      ]
    })
  ]
};
```

### 3.3 Manifest配置

```json
{
  "manifest_version": 3,
  "name": "多AI对话助手",
  "version": "1.0.0",
  "description": "集成多个AI服务的浏览器插件",
  "permissions": [
    "storage",
    "activeTab",
    "scripting",
    "webRequest"
  ],
  "host_permissions": [
    "https://chat.openai.com/*",
    "https://claude.ai/*",
    "https://gemini.google.com/*",
    "https://yiyan.baidu.com/*",
    "https://tongyi.aliyun.com/*",
    "https://xinghuo.xfyun.cn/*",
    "https://kimi.moonshot.cn/*",
    "https://www.doubao.com/*"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "action": {
    "default_popup": "popup.html",
    "default_title": "多AI对话助手"
  },
  "options_page": "options.html",
  "icons": {
    "16": "public/icons/icon16.png",
    "48": "public/icons/icon48.png",
    "128": "public/icons/icon128.png"
  }
}
```

## 4. 性能优化

### 4.1 内存管理
- 实现对话历史的分页加载
- 定期清理过期的缓存数据
- 优化iframe的创建和销毁

### 4.2 网络优化
- 实现请求队列和并发控制
- 添加请求重试机制
- 实现响应缓存

### 4.3 用户体验优化
- 实现流式响应显示
- 添加加载状态指示
- 优化界面响应速度

## 5. 安全考虑

### 5.1 数据安全
- API密钥加密存储
- 本地数据加密
- 安全的消息传递

### 5.2 权限控制
- 最小化权限申请
- 用户授权确认
- 数据访问控制

### 5.3 隐私保护
- 本地数据处理
- 匿名使用选项
- 数据清理功能

---

**文档版本**: v1.0  
**创建日期**: 2024年12月  
**技术负责人**: 开发团队